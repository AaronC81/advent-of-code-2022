Program evalFile: "../utils/aoc.bbl".

/// An unordered hash-based set, with (relatively) fast insertion by separating items into buckets.
///
/// To store an item in the set, it must have a `hash` method which returns an integer.
struct Set buckets.
impl Set {
    /// Creates a new set with a fixed number of buckets.
    static func newWithBuckets: n {
        set = Set buckets: #{}.
        n times: [ set buckets append: #{} ].
        set
    }

    /// Inserts an item into the set.
    func insert: item {
        bucket = self bucketFor: item.
        bucket contains: item $ ifFalse: [ bucket append: item ].
    }

    /// Gets the number of items in the set.
    func length {
        self buckets map: &length $ sum
    }

    /// Returns the bucket that a particular item should be placed in, based on its hash value.
    private func bucketFor: item {
        self buckets get: (item hash $ modulo: self buckets length)
    }
}

/// A direction in which a knot in the rope could move.
enum Direction {
    Up.
    Down.
    Left.
    Right.
}

// A 2D point.
struct Point x y.
impl Point {
    /// The point (0, 0).
    static func zero {
        Point x: 0 y: 0
    }

    /// Computes the distance between two points, and returns a 2-element array of the form
    /// `#{ (x distance) (y distance) }`.
    func distanceTo: other {
        #{ (self x - other x $ abs). (self y - other y $ abs) }
    }

    /// Copies this point into a new instance.
    func clone {
        Point x: self x y: self y
    }

    /// Computes a hash value for this point, for storing it in a `Set`.
    func hash {
        self x * self y $ abs
    }
}

/// A length of rope between two knots.
struct Rope head tail.
impl Rope {
    /// Moves the head of the rope in a `Direction`, and updates the tail to follow it.
    func move: dir {
        oldHead = self head clone.
        dir match mustBeOneOf: #{
            ?[ | Direction#Up    | self head y = self head y - 1 ]
            ?[ | Direction#Down  | self head y = self head y + 1 ]
            ?[ | Direction#Left  | self head x = self head x - 1 ]
            ?[ | Direction#Right | self head x = self head x + 1 ]
        }.
        self recalculateTail: oldHead.
    }

    /// Given an old head position, and assuming that the head position has already been updated,
    /// updates the tail position to follow the head.
    private func recalculateTail: oldHead {
        moveTail = false.

        // The difference movement cases between the head and tail are...
        self head distanceTo: self tail $ match mustBeOneOf: #{
            // They're in the same place - nothing needs to happen
            ?[ | #{ 0 0 } | ]

            // They're immediately adjacent - nothing needs to happen
            ?[ | #{ 1 0 } | ]
            ?[ | #{ 0 1 } | ]

            // They're immediately diagonal - nothing needs to happen
            ?[ | #{ 1 1 } | ]
            ?[ | #{ 1 1 } | ]

            // The head is further away than any of these - movement needed!
            ?[ |_| moveTail = true ]
        }.

        moveTail ifTrue: [ self tail = oldHead ]
    }
}

struct Day9.
impl Day9 {
    static func part1 {
        input = AOC readInput: 9 $ split: "\n" $ map: [ |line| line split: " " ].
        moves = #{}.
        input forEach: [ |i|
            move = i first match mustBeOneOf: #{
                ?[ | "U" | Direction#Up    ]
                ?[ | "D" | Direction#Down  ]
                ?[ | "L" | Direction#Left  ]
                ?[ | "R" | Direction#Right ]
            }.
            i last toInteger times: [
                moves append: move
            ].
        ].

        rope = Rope head: Point zero tail: Point zero.
        visitedPoints = Set newWithBuckets: 1000.
        visitedPoints insert: Point zero.
        moves forEach: [ |move|
            rope move: move.
            visitedPoints insert: rope tail.
        ].
        visitedPoints length
    }
}

Console println: Day9 part1.
